<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">es6/observable/dom/AjaxObservable.js | RxJS API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
<script data-ice="userScript" src="user/script/0-Rx.umd.min.js"></script>
<script data-ice="userScript" src="user/script/1-devtools-welcome.js"></script>
<script data-ice="userScript" src="user/script/2-custom-manual-styles.js"></script>
<link data-ice="userStyle" rel="stylesheet" href="user/css/0-main.css">
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/ReactiveX/RxJS" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/Observable.js~Observable.html">Observable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/Subject.js~Subject.html">Subject</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">observable</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/observable/ConnectableObservable.js~ConnectableObservable.html">ConnectableObservable</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">observable/dom</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/observable/dom/AjaxObservable.js~AjaxError.html">AjaxError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/observable/dom/AjaxObservable.js~AjaxResponse.html">AjaxResponse</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">operator</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/operator/groupBy.js~GroupedObservable.html">GroupedObservable</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">subject</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/subject/AsyncSubject.js~AsyncSubject.html">AsyncSubject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/subject/BehaviorSubject.js~BehaviorSubject.html">BehaviorSubject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/subject/ReplaySubject.js~ReplaySubject.html">ReplaySubject</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">symbol</div><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-$$rxSubscriber">$$rxSubscriber</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">util</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es6/util/ObjectUnsubscribedError.js~ObjectUnsubscribedError.html">ObjectUnsubscribedError</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">es6/observable/dom/AjaxObservable.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { root } from &apos;../../util/root&apos;;
import { tryCatch } from &apos;../../util/tryCatch&apos;;
import { errorObject } from &apos;../../util/errorObject&apos;;
import { Observable } from &apos;../../Observable&apos;;
import { Subscriber } from &apos;../../Subscriber&apos;;
const createXHRDefault = () =&gt; {
    let xhr = new root.XMLHttpRequest();
    if (this.crossDomain) {
        if (&apos;withCredentials&apos; in xhr) {
            xhr.withCredentials = true;
            return xhr;
        }
        else if (!!root.XDomainRequest) {
            return new root.XDomainRequest();
        }
        else {
            throw new Error(&apos;CORS is not supported by your browser&apos;);
        }
    }
    else {
        return xhr;
    }
};
function defaultGetResultSelector(response) {
    return response.response;
}
export function ajaxGet(url, resultSelector = defaultGetResultSelector, headers = null) {
    return new AjaxObservable({ method: &apos;GET&apos;, url, resultSelector, headers });
}
;
export function ajaxPost(url, body, headers) {
    return new AjaxObservable({ method: &apos;POST&apos;, url, body, headers });
}
;
export function ajaxDelete(url, headers) {
    return new AjaxObservable({ method: &apos;DELETE&apos;, url, headers });
}
;
export function ajaxPut(url, body, headers) {
    return new AjaxObservable({ method: &apos;PUT&apos;, url, body, headers });
}
;
export function ajaxGetJSON(url, resultSelector, headers) {
    const finalResultSelector = resultSelector ? (res) =&gt; resultSelector(res.response) : (res) =&gt; res.response;
    return new AjaxObservable({ method: &apos;GET&apos;, url, responseType: &apos;json&apos;, resultSelector: finalResultSelector, headers });
}
;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class AjaxObservable extends Observable {
    constructor(urlOrRequest) {
        super();
        const request = {
            async: true,
            createXHR: createXHRDefault,
            crossDomain: false,
            headers: {},
            method: &apos;GET&apos;,
            responseType: &apos;json&apos;,
            timeout: 0
        };
        if (typeof urlOrRequest === &apos;string&apos;) {
            request.url = urlOrRequest;
        }
        else {
            for (const prop in urlOrRequest) {
                if (urlOrRequest.hasOwnProperty(prop)) {
                    request[prop] = urlOrRequest[prop];
                }
            }
        }
        this.request = request;
    }
    /**
     * Creates an observable for an Ajax request with either a request object with
     * url, headers, etc or a string for a URL.
     *
     * @example
     * source = Rx.Observable.ajax(&apos;/products&apos;);
     * source = Rx.Observable.ajax( url: &apos;products&apos;, method: &apos;GET&apos; });
     *
     * @param {string|Object} request Can be one of the following:
     *   A string of the URL to make the Ajax call.
     *   An object with the following properties
     *   - url: URL of the request
     *   - body: The body of the request
     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
     *   - async: Whether the request is async
     *   - headers: Optional headers
     *   - crossDomain: true if a cross domain request, else false
     *   - createXHR: a function to override if you need to use an alternate
     *   XMLHttpRequest implementation.
     *   - resultSelector: a function to use to alter the output value type of
     *   the Observable. Gets {@link AjaxResponse} as an argument.
     * @return {Observable} An observable sequence containing the XMLHttpRequest.
     * @static true
     * @name ajax
     * @owner Observable
    */
    static _create_stub() { return null; }
    _subscribe(subscriber) {
        return new AjaxSubscriber(subscriber, this.request);
    }
}
AjaxObservable.create = (() =&gt; {
    const create = (urlOrRequest) =&gt; {
        return new AjaxObservable(urlOrRequest);
    };
    create.get = ajaxGet;
    create.post = ajaxPost;
    create.delete = ajaxDelete;
    create.put = ajaxPut;
    create.getJSON = ajaxGetJSON;
    return create;
})();
export class AjaxSubscriber extends Subscriber {
    constructor(destination, request) {
        super(destination);
        this.request = request;
        this.done = false;
        const headers = request.headers = request.headers || {};
        // force CORS if requested
        if (!request.crossDomain &amp;&amp; !headers[&apos;X-Requested-With&apos;]) {
            headers[&apos;X-Requested-With&apos;] = &apos;XMLHttpRequest&apos;;
        }
        // ensure content type is set
        if (!(&apos;Content-Type&apos; in headers)) {
            headers[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;;
        }
        // properly serialize body
        request.body = this.serializeBody(request.body, request.headers[&apos;Content-Type&apos;]);
        this.resultSelector = request.resultSelector;
        this.send();
    }
    next(e) {
        this.done = true;
        const { resultSelector, xhr, request, destination } = this;
        const response = new AjaxResponse(e, xhr, request);
        if (resultSelector) {
            const result = tryCatch(resultSelector)(response);
            if (result === errorObject) {
                this.error(errorObject.e);
            }
            else {
                destination.next(result);
            }
        }
        else {
            destination.next(response);
        }
    }
    send() {
        const { request, request: { user, method, url, async, password, headers, body } } = this;
        const createXHR = request.createXHR;
        const xhr = tryCatch(createXHR).call(request);
        if (xhr === errorObject) {
            this.error(errorObject.e);
        }
        else {
            this.xhr = xhr;
            // open XHR first
            let result;
            if (user) {
                result = tryCatch(xhr.open).call(xhr, method, url, async, user, password);
            }
            else {
                result = tryCatch(xhr.open).call(xhr, method, url, async);
            }
            if (result === errorObject) {
                this.error(errorObject.e);
                return;
            }
            // timeout and responseType can be set once the XHR is open
            xhr.timeout = request.timeout;
            xhr.responseType = request.responseType;
            // set headers
            this.setHeaders(xhr, headers);
            // now set up the events
            this.setupEvents(xhr, request);
            // finally send the request
            if (body) {
                xhr.send(body);
            }
            else {
                xhr.send();
            }
        }
    }
    serializeBody(body, contentType) {
        if (!body || typeof body === &apos;string&apos;) {
            return body;
        }
        const splitIndex = contentType.indexOf(&apos;;&apos;);
        if (splitIndex !== -1) {
            contentType = contentType.substring(0, splitIndex);
        }
        switch (contentType) {
            case &apos;application/x-www-form-urlencoded&apos;:
                return Object.keys(body).map(key =&gt; `${key}=${encodeURI(body[key])}`).join(&apos;&amp;&apos;);
            case &apos;application/json&apos;:
                return JSON.stringify(body);
        }
    }
    setHeaders(xhr, headers) {
        for (let key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
    }
    setupEvents(xhr, request) {
        const progressSubscriber = request.progressSubscriber;
        xhr.ontimeout = function xhrTimeout(e) {
            const { subscriber, progressSubscriber, request } = xhrTimeout;
            if (progressSubscriber) {
                progressSubscriber.error(e);
            }
            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.
        };
        xhr.ontimeout.request = request;
        xhr.ontimeout.subscriber = this;
        xhr.ontimeout.progressSubscriber = progressSubscriber;
        if (xhr.upload &amp;&amp; &apos;withCredentials&apos; in xhr &amp;&amp; root.XDomainRequest) {
            if (progressSubscriber) {
                xhr.onprogress = function xhrProgress(e) {
                    const { progressSubscriber } = xhrProgress;
                    progressSubscriber.next(e);
                };
                xhr.onprogress.progressSubscriber = progressSubscriber;
            }
            xhr.onerror = function xhrError(e) {
                const { progressSubscriber, subscriber, request } = xhrError;
                if (progressSubscriber) {
                    progressSubscriber.error(e);
                }
                subscriber.error(new AjaxError(&apos;ajax error&apos;, this, request));
            };
            xhr.onerror.request = request;
            xhr.onerror.subscriber = this;
            xhr.onerror.progressSubscriber = progressSubscriber;
        }
        xhr.onreadystatechange = function xhrReadyStateChange(e) {
            const { subscriber, progressSubscriber, request } = xhrReadyStateChange;
            if (this.readyState === 4) {
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                let status = this.status === 1223 ? 204 : this.status;
                let response = (this.responseType === &apos;text&apos; ? (this.response || this.responseText) : this.response);
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status === 0) {
                    status = response ? 200 : 0;
                }
                if (200 &lt;= status &amp;&amp; status &lt; 300) {
                    if (progressSubscriber) {
                        progressSubscriber.complete();
                    }
                    subscriber.next(e);
                    subscriber.complete();
                }
                else {
                    if (progressSubscriber) {
                        progressSubscriber.error(e);
                    }
                    subscriber.error(new AjaxError(&apos;ajax error &apos; + status, this, request));
                }
            }
        };
        xhr.onreadystatechange.subscriber = this;
        xhr.onreadystatechange.progressSubscriber = progressSubscriber;
        xhr.onreadystatechange.request = request;
    }
    unsubscribe() {
        const { done, xhr } = this;
        if (!done &amp;&amp; xhr &amp;&amp; xhr.readyState !== 4) {
            xhr.abort();
        }
        super.unsubscribe();
    }
}
/** A normalized AJAX response */
export class AjaxResponse {
    constructor(originalEvent, xhr, request) {
        this.originalEvent = originalEvent;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
        this.responseType = xhr.responseType;
        switch (this.responseType) {
            case &apos;json&apos;:
                if (&apos;response&apos; in xhr) {
                    this.response = xhr.response;
                }
                else {
                    this.response = JSON.parse(xhr.responseText || &apos;&apos;);
                }
                break;
            case &apos;xml&apos;:
                this.response = xhr.responseXML;
                break;
            case &apos;text&apos;:
            default:
                this.response = (&apos;response&apos; in xhr) ? xhr.response : xhr.responseText;
                break;
        }
    }
}
/** A normalized AJAX error */
export class AjaxError extends Error {
    constructor(message, xhr, request) {
        super(message);
        this.message = message;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
    }
}
export class AjaxTimeoutError extends AjaxError {
    constructor(xhr, request) {
        super(&apos;ajax timeout&apos;, xhr, request);
    }
}
//# sourceMappingURL=AjaxObservable.js.map</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.6)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
